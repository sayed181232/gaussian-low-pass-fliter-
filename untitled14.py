# -*- coding: utf-8 -*-
"""Untitled14.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QuG1-pQX10dHfvnBn_zS-Rt4P0W0lwem

problem programing (1)
gaussian low pass fliter on Fig0441(a)
"""

from google.colab import drive
drive.mount("/content/drive")

!ls "/content/drive/My Drive/di"

import numpy as np
import matplotlib.pyplot as plt
import cv2

def gaussian_lowpass_filter(M, N, u0, v0, sigma):
    """
    Create a Gaussian low-pass filter of size MxN with center (u0, v0) and standard deviation sigma.
    """
    # Create a grid of coordinates (u, v)
    u = np.arange(M)
    v = np.arange(N)
    U, V = np.meshgrid(u, v)

    # Shift the origin of the coordinates to the center
    U = U - u0
    V = V - v0

    # Calculate the Gaussian filter
    H = (np.exp(- (U**2 + V**2) / (2 * sigma**2)))

    return H

def apply_filter_to_image(image, M, N, u0, v0, sigma):
    """
    Apply the Gaussian low-pass filter to an image.
    """
    # Step 1: Get the Gaussian filter
    gaussian_filter = gaussian_lowpass_filter(M, N, u0, v0, sigma)

    # Step 2: Perform Fourier Transform of the image
    image_f = np.fft.fft2(image)

    # Step 3: Shift the zero-frequency component to the center
    image_f_shifted = np.fft.fftshift(image_f)

    # Step 4: Multiply the image by the Gaussian filter in the frequency domain
    filtered_f_shifted = image_f_shifted * gaussian_filter

    # Step 5: Inverse Fourier Transform to get the filtered image
    filtered_f = np.fft.ifftshift(filtered_f_shifted)
    filtered_image = np.fft.ifft2(filtered_f)

    # Take the absolute value (since the result can have complex numbers)
    return np.abs(filtered_image)

image_path = '/content/drive/My Drive/di/Fig0441(a)(characters_test_pattern).jpg'  # Replace with your image path
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)  # Read as grayscale

# Parameters for the Gaussian filter
M,N = image.shape  # Use the same size as the image
u0, v0 = M//2, N//2  # Center of the filter
#sigma = 140  # Standard deviation (controls the spread)

# Generate the Gaussian lowpass filter
#gaussian_filter = apply_filter_to_image(image, M, N, u0, v0, sigma)

# Display the results
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

# Show the original image
axes[0].imshow(image, cmap='gray')
axes[0].set_title("Original Image")
axes[0].axis('off')

# Show the noisy image
axes[1].imshow(apply_filter_to_image(image, M, N, u0, v0, sigma=50), cmap='gray')
axes[1].set_title("gaussian_filter sigma=50)")
axes[1].axis('off')
# Show the filtered image with kernel 3*3
axes[2].imshow( apply_filter_to_image(image, M, N, u0, v0, sigma=100) , cmap='gray')
axes[2].set_title("gaussian_filter sigma=100)")
axes[2].axis('off')